name: 🚀 Deploy UrbanMail - Postal Server (Ruby/Rails)

# Controle de concorrência - ÚNICO deploy por vez
concurrency:
  group: urbanmail-production-deploy
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '72.60.10.112'
  VPS_USER: 'root'
  APP_DIR: '/var/www/urbanmail'
  APP_PORT: '3030'
  IMAGE_NAME: 'urbanmail-postal'
  CONTAINER_NAME: 'urbanmail-postal-container'
  DOMAIN: 'www.urbanmail.com.br'
  DOCKER_NETWORK: 'urbanmail-network'
  DATA_VOLUME: 'urbanmail-data-vol'
  CONFIG_VOLUME: 'urbanmail-config-vol'
  DB_VOLUME: 'urbanmail-db-vol'

jobs:
  analyze-changes:
    name: 🔍 Analisar Mudanças
    runs-on: ubuntu-latest
    outputs:
      has_code_changes: ${{ steps.changes.outputs.has_code_changes }}
      has_package_changes: ${{ steps.changes.outputs.has_package_changes }}
      has_config_changes: ${{ steps.changes.outputs.has_config_changes }}
      needs_restart: ${{ steps.changes.outputs.needs_restart }}
      deploy_type: ${{ steps.changes.outputs.deploy_type }}
    
    steps:
    - name: 📥 Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    - name: 🔍 Analisar arquivos alterados
      id: changes
      run: |
        echo "🔍 Analisando mudanças desde o último commit..."
        
        # Obter arquivos alterados
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "all")
        echo "📁 Arquivos alterados:"
        echo "$CHANGED_FILES"
        
        # Inicializar flags
        HAS_CODE=false
        HAS_PACKAGE=false
        HAS_CONFIG=false
        NEEDS_RESTART=false
        
        # Analisar tipos de mudanças para UrbanMail (aplicação Ruby/Rails)
        if echo "$CHANGED_FILES" | grep -E "(app/|lib/|config/|\.rb|Dockerfile|nginx\.conf|\.env)" > /dev/null || [ "$CHANGED_FILES" = "all" ]; then
          HAS_CODE=true
          echo "✅ Mudanças de código detectadas"
        fi
        
        if echo "$CHANGED_FILES" | grep -E "(Gemfile|Gemfile\.lock)" > /dev/null; then
          HAS_PACKAGE=true
          echo "📦 Mudanças em dependências (gems) detectadas"
        fi
        
        if echo "$CHANGED_FILES" | grep -E "(\.env|Dockerfile|\.dockerignore|nginx\.conf)" > /dev/null; then
          HAS_CONFIG=true
          echo "⚙️ Mudanças de configuração detectadas"
        fi
        
        # Determinar se precisa restart
        if [[ "$HAS_CODE" == "true" || "$HAS_CONFIG" == "true" ]]; then
          NEEDS_RESTART=true
        fi
        
        # Determinar tipo de deploy
        if [[ "$HAS_PACKAGE" == "true" ]]; then
          DEPLOY_TYPE="full"
          echo "🔄 Deploy completo necessário (dependências mudaram)"
        elif [[ "$HAS_CODE" == "true" ]]; then
          DEPLOY_TYPE="code-only"
          echo "📝 Deploy apenas de código"
        elif [[ "$HAS_CONFIG" == "true" ]]; then
          DEPLOY_TYPE="config-only"
          echo "⚙️ Deploy apenas de configuração"
        else
          DEPLOY_TYPE="minimal"
          echo "📋 Deploy mínimo (docs/workflows)"
        fi
        
        # Definir outputs
        echo "has_code_changes=$HAS_CODE" >> $GITHUB_OUTPUT
        echo "has_package_changes=$HAS_PACKAGE" >> $GITHUB_OUTPUT
        echo "has_config_changes=$HAS_CONFIG" >> $GITHUB_OUTPUT
        echo "needs_restart=$NEEDS_RESTART" >> $GITHUB_OUTPUT
        echo "deploy_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT

  deploy:
    name: 🚀 Deploy Docker
    runs-on: ubuntu-latest
    needs: analyze-changes
    timeout-minutes: 45
    
    steps:
    - name: 📋 Info do Deploy Docker
      run: |
        echo "🚀 Deploy UrbanMail Server com Docker"
        echo "=============================================="
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Tipo de Deploy: ${{ needs.analyze-changes.outputs.deploy_type }}"
        echo "Mudanças de Código: ${{ needs.analyze-changes.outputs.has_code_changes }}"
        echo "Mudanças de Dependências: ${{ needs.analyze-changes.outputs.has_package_changes }}"
        echo "Precisa Restart: ${{ needs.analyze-changes.outputs.needs_restart }}"
        echo "=============================================="

    - name: 🔑 Configurar SSH
      run: |
        echo "🔑 Configurando SSH para deploy..."
        
        # Instalar sshpass para autenticação por senha
        sudo apt-get update -qq
        sudo apt-get install -y sshpass
        
        # Configurar SSH com otimizações para conexões longas
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Configurar SSH client com keepalive
        cat > ~/.ssh/config << 'EOL'
        Host *
          ServerAliveInterval 60
          ServerAliveCountMax 120
          TCPKeepAlive yes
          ControlMaster auto
          ControlPath ~/.ssh/control-%h-%p-%r
          ControlPersist 600
          ConnectTimeout 30
        EOL
        chmod 600 ~/.ssh/config
        
        # Adicionar host conhecido para evitar prompt de verificação
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
        
        # Testar conexão SSH com senha e keepalive
        echo "🔍 Testando conexão SSH com configurações otimizadas..."
        if sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'Conexão SSH bem-sucedida'"; then
          echo "✅ SSH configurado e testado com sucesso"
        else
          echo "❌ Falha na conexão SSH. Verifique se:"
          echo "  1. A secret VPS_PASSWORD contém a senha correta"
          echo "  2. O servidor ${{ env.VPS_HOST }} está acessível"
          echo "  3. O usuário ${{ env.VPS_USER }} existe e aceita autenticação por senha"
          exit 1
        fi

    - name: 🔍 Verificar e instalar Docker na VPS
      run: |
        echo "🔍 Verificando e instalando Docker se necessário..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo '=== Verificando Docker na VPS ==='
          
          # Verificar se Docker está instalado
          if ! command -v docker &> /dev/null; then
            echo '📦 Docker não encontrado, instalando...'
            
            # Atualizar sistema
            apt-get update -y
            
            # Instalar dependências
            apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
            
            # Adicionar chave GPG do Docker
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            
            # Adicionar repositório Docker
            echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Instalar Docker
            apt-get update -y
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            
            # Iniciar Docker
            systemctl start docker
            systemctl enable docker
            
            echo '✅ Docker instalado com sucesso'
          else
            echo '✅ Docker já está instalado'
          fi
          
          # Verificar versão do Docker
          echo 'Docker version:'
          docker --version
          
          echo ''
          echo 'Docker service status:'
          systemctl is-active docker || systemctl start docker
          
          echo ''
          echo 'Docker Containers atuais:'
          docker ps --format 'table {{.Names}}\t{{.Status}}' | grep ${{ env.CONTAINER_NAME }} || echo 'Container não rodando'
          
          echo ''
          echo 'Configuração de Firewall/Porta ${{ env.APP_PORT }}:'
          # Verificar se a porta está sendo usada
          netstat -tulpn | grep :${{ env.APP_PORT }} || echo 'Porta ${{ env.APP_PORT }} livre'
          
          # Verificar se iptables está bloqueando a porta
          iptables -L INPUT -n | grep ${{ env.APP_PORT }} || echo 'Nenhuma regra específica para porta ${{ env.APP_PORT }}'
          
          echo ''
          echo 'Ruby version:'
          ruby --version || echo 'Ruby não instalado'
          
          echo ''
          echo 'Última atualização:'
          cd ${{ env.APP_DIR }} && git log --oneline -1 2>/dev/null || echo 'Repositório não inicializado'
        "

    - name: 📥 Checkout do código
      uses: actions/checkout@v4
    
    # Assets serão compilados dentro do Docker build

    - name: 📦 Transferir código para VPS
      run: |
        echo "📦 Transferindo código para VPS via rsync..."
        
        # Instalar rsync
        sudo apt-get update -qq
        sudo apt-get install -y rsync
        
        # Log detalhado da conectividade
        echo "🔍 Verificando conectividade SSH antes da transferência..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no -v ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Conectividade SSH confirmada'
          free -h
          df -h /
          docker --version
        " 2>&1 | head -20
        
        # Limpar diretório remoto
        echo "🧹 Limpando diretório remoto..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          rm -rf ${{ env.APP_DIR }}
          mkdir -p ${{ env.APP_DIR }}
          echo 'Diretório limpo e recriado'
        "
        
        # Transferir código usando rsync com logs detalhados
        echo "🚀 Iniciando transferência rsync..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" rsync -avz --delete --progress \
          --exclude='.git/' \
          --exclude='vendor/bundle/' \
          --exclude='.claude/' \
          --exclude='*.log' \
          --exclude='*.tmp' \
          --exclude='.DS_Store' \
          --exclude='log/' \
          --exclude='tmp/' \
          --exclude='spec/' \
          --exclude='public/assets/' \
          -e "ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60" \
          ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.APP_DIR }}/
        
        # Verificar transferência com logs detalhados
        echo "✅ Verificando transferência..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          echo '📊 Status da transferência:'
          echo '  - Diretório atual:' \$(pwd)
          echo '  - Espaço em disco:' \$(df -h . | tail -1)
          echo '  - Total de arquivos:' \$(find . -type f | wc -l)
          
          if [ -d app ] && [ -f Gemfile ] && [ -f config.ru ]; then
            echo '✅ Código Rails transferido com sucesso'
            echo '📂 Estrutura transferida:'
            ls -la | grep -E '(app|config|lib|Gemfile)' || echo 'Verificando estrutura...'
            echo '📂 Gemfile:' \$(wc -l Gemfile 2>/dev/null || echo 'N/A')
            echo '📂 Config.ru:' \$(wc -l config.ru 2>/dev/null || echo 'N/A')
          else
            echo '❌ ERRO: Estrutura Rails não encontrada!'
            echo '📂 Conteúdo atual do diretório:'
            ls -la
            echo '📂 Estrutura de diretórios:'
            find . -maxdepth 2 -type d
            exit 1
          fi
        "

    - name: 🚀 Deploy usando Docker
      run: |
        echo "🚀 Executando deploy com Docker..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Deploy UrbanMail Server usando Docker com isolamento completo
          echo '🚀 Executando deploy UrbanMail Server com Docker (isolado)...'
          
          # Parar e remover container anterior se existir
          echo '🔄 Parando container anterior...'
          docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          
          # Criar rede Docker isolada para UrbanMail
          echo '🌐 Criando rede Docker isolada...'
          if ! docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
            docker network create ${{ env.DOCKER_NETWORK }}
            echo '  ✅ Rede ${{ env.DOCKER_NETWORK }} criada com sucesso'
          else
            echo '  ✅ Rede ${{ env.DOCKER_NETWORK }} já existe'
          fi
          
          # Verificar se a rede foi criada corretamente
          if docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
            echo '  ✅ Rede ${{ env.DOCKER_NETWORK }} confirmada'
            docker network inspect ${{ env.DOCKER_NETWORK }} --format '{{.Name}}: {{.Driver}}'
          else
            echo '  ❌ Falha ao criar/verificar rede ${{ env.DOCKER_NETWORK }}'
            echo '  📋 Redes Docker disponíveis:'
            docker network ls
            exit 1
          fi
          
          # Criar volumes Docker nomeados para persistência de dados
          echo '💾 Criando volumes Docker nomeados...'
          docker volume create ${{ env.DATA_VOLUME }} 2>/dev/null || echo '  (volume data já existe)'
          docker volume create ${{ env.CONFIG_VOLUME }} 2>/dev/null || echo '  (volume config já existe)'
          docker volume create ${{ env.DB_VOLUME }} 2>/dev/null || echo '  (volume db já existe)'
          
          # Verificar processos Docker ativos (sem matar)
          echo '💀 Verificando processos Docker...'
          if pgrep -f 'docker build' >/dev/null 2>&1; then
            echo '  ⚠️ Processos docker build encontrados (continuando)'
          fi
          if pgrep -f 'npm ci' >/dev/null 2>&1; then
            echo '  ⚠️ Processos npm ci encontrados (continuando)'
          fi
          echo '  ✅ Verificação concluída'
          
          # Limpeza Docker simplificada
          echo '🧹 Limpando recursos Docker...'
          
          # Verificar se Docker está funcionando
          if ! docker --version >/dev/null 2>&1; then
            echo '❌ Docker não encontrado!'
            exit 1
          fi
          
          # Verificar se o serviço Docker está rodando
          if ! systemctl is-active --quiet docker; then
            echo '🔄 Iniciando serviço Docker...'
            systemctl start docker
            sleep 5
          fi
          
          # Teste básico do Docker
          if ! docker info >/dev/null 2>&1; then
            echo '❌ Docker não está funcionando corretamente!'
            systemctl status docker
            exit 1
          fi
          
          echo '✅ Docker está funcionando corretamente'
          
          # Limpeza básica e segura
          echo '  - Removendo imagem anterior se existir...'
          docker rmi ${{ env.IMAGE_NAME }}:latest 2>/dev/null || echo '    (nenhuma imagem para remover)'
          
          echo '  - Limpeza rápida de recursos não utilizados...'
          docker system prune -f 2>/dev/null || echo '    (falha na limpeza, continuando)'
          
          echo '  ✅ Limpeza concluída'
          
          # Build da imagem Docker com retry automático
          echo '🏗️ Building Docker image com retry automático...'
          
          # Função de retry para docker build
          build_with_retry() {
            local max_attempts=3
            local attempt=1
            local timeout_duration=1800  # 30 minutos
            
            while [ \$attempt -le \$max_attempts ]; do
              echo \"🔄 Tentativa \$attempt/\$max_attempts do Docker build...\"
              
              # Usar timeout e Dockerfile padrão da aplicação Rails
              if timeout \$timeout_duration docker build --network=host --no-cache --pull -t ${{ env.IMAGE_NAME }}:latest .; then
                echo \"✅ Docker build bem-sucedido na tentativa \$attempt\"
                return 0
              else
                local exit_code=\$?
                echo \"❌ Docker build falhou na tentativa \$attempt (exit code: \$exit_code)\"
                
                if [ \$attempt -eq \$max_attempts ]; then
                  echo \"💥 Todas as tentativas de build falharam\"
                  return \$exit_code
                fi
                
                # Limpar containers e imagens órfãs antes de retry
                echo \"🧹 Limpando recursos Docker antes do retry...\"
                docker system prune -f --volumes 2>/dev/null || true
                docker builder prune -f 2>/dev/null || true
                
                # Aguardar antes do próximo retry
                local wait_time=\$((attempt * 30))
                echo \"⏳ Aguardando \$wait_time segundos antes do próximo retry...\"
                sleep \$wait_time
              fi
              
              attempt=\$((attempt + 1))
            done
          }
          
          # Executar build com retry
          build_with_retry
          
          # Verificar se a imagem foi criada
          if ! docker images | grep -q ${{ env.IMAGE_NAME }}; then
            echo '❌ Falha ao criar imagem Docker!'
            exit 1
          fi
          
          echo '✅ Imagem Docker criada com sucesso'
          
          # Iniciar container isolado na porta ${{ env.APP_PORT }}
          echo '🚀 Iniciando container UrbanMail isolado na porta ${{ env.APP_PORT }}...'
          
          # Verificar novamente se a rede existe antes de iniciar o container
          if ! docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
            echo '❌ Rede ${{ env.DOCKER_NETWORK }} não encontrada antes de iniciar container!'
            echo '📋 Redes Docker disponíveis:'
            docker network ls
            echo '🔧 Tentando recriar a rede...'
            docker network create ${{ env.DOCKER_NETWORK }}
            
            if ! docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
              echo '❌ Falha ao criar rede ${{ env.DOCKER_NETWORK }}'
              exit 1
            else
              echo '✅ Rede ${{ env.DOCKER_NETWORK }} criada com sucesso'
            fi
          fi
          
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            --network ${{ env.DOCKER_NETWORK }} \
            -p ${{ env.APP_PORT }}:5000 \
            --restart unless-stopped \
            --memory=2g \
            --cpus=2 \
            --tmpfs /tmp:noexec,nosuid,size=100m \
            --volume ${{ env.DATA_VOLUME }}:/opt/postal/data \
            --volume ${{ env.CONFIG_VOLUME }}:/config \
            --volume ${{ env.DB_VOLUME }}:/var/lib/mysql \
            --health-cmd=\"curl -f http://localhost:5000/ || exit 1\" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            -e RAILS_ENV=production \
            -e POSTAL_CONFIG_FILE_PATH=/config/postal.yml \
            -e DATABASE_URL=mysql2://postal:password@localhost/postal \
            -e SECRET_KEY_BASE=\$(openssl rand -hex 64) \
            --label app=urbanmail-postal \
            --label version=v1 \
            --label environment=production \
            ${{ env.IMAGE_NAME }}:latest
          
          # Aguardar container inicializar e verificar logs imediatamente
          echo '⏳ Aguardando container inicializar...'
          sleep 5
          
          # Mostrar status inicial do container
          echo '📋 Status inicial do container:'
          docker ps -a | grep ${{ env.CONTAINER_NAME }} || echo 'Container não encontrado'
          
          # Mostrar logs iniciais para debug
          echo '📋 Logs iniciais do container:'
          docker logs ${{ env.CONTAINER_NAME }} 2>&1 || echo 'Sem logs disponíveis'
          
          # Aguardar mais um pouco
          echo '⏳ Aguardando mais 10 segundos...'
          sleep 10
          
          # Verificar se container ainda está rodando
          if ! docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '❌ Container não está rodando!'
            echo '📋 Status final do container:'
            docker ps -a | grep ${{ env.CONTAINER_NAME }} || echo 'Container não encontrado'
            echo '📋 Logs completos do container:'
            docker logs ${{ env.CONTAINER_NAME }} 2>&1 || echo 'Sem logs disponíveis'
            echo '📋 Inspecionar container:'
            docker inspect ${{ env.CONTAINER_NAME }} --format='{{.State.Status}}: {{.State.Error}}' || echo 'Erro ao inspecionar'
            exit 1
          else
            echo '✅ Container está rodando!'
          fi
          
          # Verificar se está funcionando
          echo '🔍 Testando UrbanMail Server...'
          for i in {1..10}; do
            # Testar conectividade com logs detalhados
            echo \"⏳ Tentativa \$i/10 - Testando http://localhost:${{ env.APP_PORT }}/\"
            
            # Primeiro teste com curl verbose para debug
            if [ \$i -eq 1 ] || [ \$i -eq 5 ]; then
              echo '🔍 Teste detalhado de conectividade:'
              curl -v --connect-timeout 5 --max-time 10 http://localhost:${{ env.APP_PORT }}/ 2>&1 || echo 'Curl falhou'
            fi
            
            if curl -f -s --connect-timeout 5 --max-time 10 http://localhost:${{ env.APP_PORT }}/ >/dev/null 2>&1; then
              echo '✅ UrbanMail Server funcionando!'
              break
            else
              echo \"❌ Tentativa \$i/10 falhou\"
              if [ \$i -eq 2 ] || [ \$i -eq 5 ] || [ \$i -eq 8 ]; then
                echo '📋 Logs do container (tentativa '\$i'):'
                docker logs ${{ env.CONTAINER_NAME }} --tail 20 2>&1
                echo '📋 Status do container:'
                docker ps | grep ${{ env.CONTAINER_NAME }} || echo 'Container não está mais rodando'
              fi
              sleep 10
            fi
            
            if [ \$i -eq 10 ]; then
              echo '❌ UrbanMail Server não respondeu após 10 tentativas'
              echo '📋 Logs completos do container:'
              docker logs ${{ env.CONTAINER_NAME }}
              echo '📋 Status dos processos no container:'
              docker exec ${{ env.CONTAINER_NAME }} ps aux || echo 'Container não está acessível'
              exit 1
            fi
          done
          
          echo '✅ UrbanMail Server deployed successfully on port ${{ env.APP_PORT }}'
          echo '📊 Status do container:'
          docker ps | grep ${{ env.CONTAINER_NAME }}
          echo '✅ Deploy containerizado concluído'
        "

    - name: 🌐 Configurar Nginx para UrbanMail
      run: |
        echo "🌐 Configurando Nginx para UrbanMail Server..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          echo '🔧 Configurando proxy reverso isolado para UrbanMail...'
          
          # Verificar se Nginx está instalado e rodando
          if ! systemctl is-active --quiet nginx; then
            echo '📦 Nginx não está rodando, iniciando...'
            systemctl start nginx || echo 'Falha ao iniciar Nginx'
          fi
          
          # Criar configuração Nginx isolada para UrbanMail
          cat > /etc/nginx/sites-available/urbanmail-v2.conf << 'EOF'
        # UrbanMail Postal - Configuração isolada
        upstream urbanmail_backend {
            server 127.0.0.1:3030 max_fails=3 fail_timeout=30s;
            keepalive 32;
        }

        server {
            listen 80;
            server_name urbanmail.com.br www.urbanmail.com.br;

            # Rate limiting
            limit_req_zone \$binary_remote_addr zone=urbanmail:10m rate=10r/s;
            limit_req zone=urbanmail burst=20 nodelay;

            # Configurações de segurança específicas do UrbanMail
            add_header X-Frame-Options DENY;
            add_header X-Content-Type-Options nosniff;
            add_header X-XSS-Protection \"1; mode=block\";
            add_header Referrer-Policy \"strict-origin-when-cross-origin\";
            add_header X-App \"UrbanMail-Postal\" always;

            # Client settings
            client_max_body_size 10M;
            client_body_timeout 60s;

            # Proxy para UrbanMail Server (isolado)
            location / {
                proxy_pass http://urbanmail_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection \"upgrade\";
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_set_header X-App-Name \"UrbanMail\";
                proxy_cache_bypass \$http_upgrade;
                proxy_connect_timeout 10s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }

            # Health check endpoint
            location /health {
                proxy_pass http://urbanmail_backend/;
                access_log off;
                add_header X-Health-Check \"UrbanMail-Postal\" always;
            }

            # Logs específicos do UrbanMail
            access_log /var/log/nginx/urbanmail_v2_access.log combined;
            error_log /var/log/nginx/urbanmail_v2_error.log warn;
        }
        EOF
          
          # Ativar site UrbanMail isolado
          echo '🔗 Ativando configuração Nginx...'
          # Remover configuração antiga se existir
          rm -f /etc/nginx/sites-enabled/urbanmail.conf 2>/dev/null || true
          # Ativar nova configuração
          ln -sf /etc/nginx/sites-available/urbanmail-v2.conf /etc/nginx/sites-enabled/urbanmail-v2.conf
          
          # Testar configuração Nginx
          if nginx -t; then
            echo '✅ Configuração Nginx válida'
            systemctl reload nginx
            echo '✅ Nginx recarregado'
          else
            echo '❌ Erro na configuração Nginx'
            exit 1
          fi
          
          echo '✅ Configuração do Nginx concluída'
        "

    - name: 🔍 Verificação Final
      run: |
        echo "🔍 Verificação final..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Verificar status do container e isolamento
          echo '🔍 Verificando isolamento do container UrbanMail:'
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '✅ Container UrbanMail rodando'
            echo '📊 Detalhes do container:'
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Networks}}' | grep ${{ env.CONTAINER_NAME }}
            
            echo '🌐 Rede Docker:'
            docker network ls | grep ${{ env.DOCKER_NETWORK }} || echo '  (rede não encontrada)'
            
            echo '💾 Volumes Docker:'
            docker volume ls | grep -E '(${{ env.DATA_VOLUME }}|${{ env.UPLOADS_VOLUME }})' || echo '  (volumes não encontrados)'
            
            echo '🏷️ Labels do container:'
            docker inspect ${{ env.CONTAINER_NAME }} --format '{{range \$key, \$value := .Config.Labels}}{{printf \"%s=%s\n\" \$key \$value}}{{end}}' | grep -E '(app|version|environment)' || echo '  (sem labels relevantes)'
          else
            echo '❌ Container UrbanMail não encontrado'
            exit 1
          fi
          
          # Verificar health check da aplicação (localhost)
          echo '🔍 Testando UrbanMail Server (localhost)...'
          if curl -f -s http://localhost:${{ env.APP_PORT }}/ >/dev/null 2>&1; then
            echo '✅ UrbanMail Server respondendo no localhost:${{ env.APP_PORT }}'
            echo '📋 Resposta da aplicação:'
            curl -s http://localhost:${{ env.APP_PORT }}/ | head -10 || echo 'Falha ao obter resposta'
          else
            echo '❌ UrbanMail Server não está respondendo no localhost'
            docker logs ${{ env.CONTAINER_NAME }} --tail 10
            exit 1
          fi
          
          # Verificar health check via Nginx (domínio) - se configurado
          echo '🔍 Testando conectividade do domínio ${{ env.DOMAIN }}...'
          
          # Testar se o domínio responde (HTTP ou HTTPS)
          if curl -f -s -I http://${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '✅ Domínio ${{ env.DOMAIN }} respondendo via HTTP'
            
            # Verificar se há redirecionamento para HTTPS
            if curl -f -s -I http://${{ env.DOMAIN }}/ | grep -q '301\\|302'; then
              echo '✅ Redirecionamento HTTP → HTTPS configurado'
            else
              echo '📝 Site respondendo em HTTP (SSL pode não estar configurado ainda)'
            fi
          else
            echo '⚠️ Domínio ${{ env.DOMAIN }} não está respondendo via HTTP'
          fi
          
          # Testar HTTPS se disponível
          if curl -f -s -k https://${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '✅ Site HTTPS respondendo em https://${{ env.DOMAIN }}'
          else
            echo '📝 HTTPS não disponível (SSL pode não estar configurado)'
          fi
          
          # Testar domínio sem www (urbanmail.com.br)
          if curl -f -s -k https://urbanmail.com.br/ >/dev/null 2>&1; then
            echo '✅ Site HTTPS respondendo em https://urbanmail.com.br'
          elif curl -f -s http://urbanmail.com.br/ >/dev/null 2>&1; then
            echo '✅ Site HTTP respondendo em http://urbanmail.com.br'
          else
            echo '📝 Domínio urbanmail.com.br pode não estar configurado'
          fi
          
        "

    - name: 📊 Relatório do Deploy
      if: always()
      run: |
        echo "📊 RELATÓRIO DO DEPLOY DOCKER"
        echo "============================="
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Tipo de Deploy: ${{ needs.analyze-changes.outputs.deploy_type }}'
          echo 'Restart Executado: ${{ needs.analyze-changes.outputs.needs_restart }}'
          echo 'Dependências Atualizadas: ${{ needs.analyze-changes.outputs.has_package_changes }}'
          echo ''
          
          echo '=== Status do Container Isolado ==='
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '📊 Container UrbanMail:'
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}' | head -1
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}' | grep ${{ env.CONTAINER_NAME }}
            
            echo ''
            echo '🌐 Recursos Docker isolados:'
            echo '  - Rede: ${{ env.DOCKER_NETWORK }}'
            echo '  - Volume Data: ${{ env.DATA_VOLUME }}'
            echo '  - Volume Config: ${{ env.CONFIG_VOLUME }}'
            echo '  - Volume DB: ${{ env.DB_VOLUME }}'
            echo '  - Imagem: ${{ env.IMAGE_NAME }}:latest'
          else
            echo '❌ Container UrbanMail não encontrado'
          fi
          
          echo ''
          echo '=== Último Commit ==='
          cd ${{ env.APP_DIR }} && git log --oneline -1 2>/dev/null || echo 'Repositório git não inicializado (deploy via rsync)'
          
          echo ''
          echo '🌐 URLs de Acesso:'
          echo '  - Site Principal: https://${{ env.DOMAIN }}'
          echo '  - Site Alternativo: https://urbanmail.com.br'
          echo '  - Acesso Direto: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}'
          echo '  - API Health: https://${{ env.DOMAIN }}/health'
          echo '⚡ Deploy Docker UrbanMail concluído!'
        "

    - name: 🎉 Deploy Concluído
      run: |
        echo "🎉 DEPLOY URBANMAIL POSTAL ISOLADO REALIZADO COM SUCESSO!"
        echo "⚡ Tipo: ${{ needs.analyze-changes.outputs.deploy_type }}"
        echo "🐳 Deploy completamente isolado em VPS compartilhada:"
        echo "   - Container: ${{ env.CONTAINER_NAME }}"
        echo "   - Rede isolada: ${{ env.DOCKER_NETWORK }}"
        echo "   - Volumes nomeados: ${{ env.DATA_VOLUME }}, ${{ env.CONFIG_VOLUME }}, ${{ env.DB_VOLUME }}"
        echo "   - Imagem única: ${{ env.IMAGE_NAME }}:latest"
        echo "🔒 SSL/HTTPS configurado com Let's Encrypt"
        echo ""
        echo "🌐 URLs de Acesso:"
        echo "  - Site Principal: https://${{ env.DOMAIN }}"
        echo "  - Site Alternativo: https://urbanmail.com.br"
        echo "  - Acesso Direto VPS: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo "  - API Health: https://${{ env.DOMAIN }}/health"
        echo ""
        echo "✅ UrbanMail está online e funcionando!"
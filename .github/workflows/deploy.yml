name: üöÄ Deploy UrbanMail - Postal Server (Ruby/Rails)

# Controle de concorr√™ncia - √öNICO deploy por vez
concurrency:
  group: urbanmail-production-deploy
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '72.60.10.112'
  VPS_USER: 'root'
  APP_DIR: '/var/www/urbanmail'
  APP_PORT: '3030'
  IMAGE_NAME: 'urbanmail-postal'
  CONTAINER_NAME: 'urbanmail-postal-container'
  DOMAIN: 'www.urbanmail.com.br'
  DOCKER_NETWORK: 'urbanmail-network'
  DATA_VOLUME: 'urbanmail-data-vol'
  CONFIG_VOLUME: 'urbanmail-config-vol'
  DB_VOLUME: 'urbanmail-db-vol'

jobs:
  analyze-changes:
    name: üîç Analisar Mudan√ßas
    runs-on: ubuntu-latest
    outputs:
      has_code_changes: ${{ steps.changes.outputs.has_code_changes }}
      has_package_changes: ${{ steps.changes.outputs.has_package_changes }}
      has_config_changes: ${{ steps.changes.outputs.has_config_changes }}
      needs_restart: ${{ steps.changes.outputs.needs_restart }}
      deploy_type: ${{ steps.changes.outputs.deploy_type }}
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    - name: üîç Analisar arquivos alterados
      id: changes
      run: |
        echo "üîç Analisando mudan√ßas desde o √∫ltimo commit..."
        
        # Obter arquivos alterados
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "all")
        echo "üìÅ Arquivos alterados:"
        echo "$CHANGED_FILES"
        
        # Inicializar flags
        HAS_CODE=false
        HAS_PACKAGE=false
        HAS_CONFIG=false
        NEEDS_RESTART=false
        
        # Analisar tipos de mudan√ßas para UrbanMail (aplica√ß√£o Ruby/Rails)
        if echo "$CHANGED_FILES" | grep -E "(app/|lib/|config/|\.rb|Dockerfile|nginx\.conf|\.env)" > /dev/null || [ "$CHANGED_FILES" = "all" ]; then
          HAS_CODE=true
          echo "‚úÖ Mudan√ßas de c√≥digo detectadas"
        fi
        
        if echo "$CHANGED_FILES" | grep -E "(Gemfile|Gemfile\.lock)" > /dev/null; then
          HAS_PACKAGE=true
          echo "üì¶ Mudan√ßas em depend√™ncias (gems) detectadas"
        fi
        
        if echo "$CHANGED_FILES" | grep -E "(\.env|Dockerfile|\.dockerignore|nginx\.conf)" > /dev/null; then
          HAS_CONFIG=true
          echo "‚öôÔ∏è Mudan√ßas de configura√ß√£o detectadas"
        fi
        
        # Determinar se precisa restart
        if [[ "$HAS_CODE" == "true" || "$HAS_CONFIG" == "true" ]]; then
          NEEDS_RESTART=true
        fi
        
        # Determinar tipo de deploy
        if [[ "$HAS_PACKAGE" == "true" ]]; then
          DEPLOY_TYPE="full"
          echo "üîÑ Deploy completo necess√°rio (depend√™ncias mudaram)"
        elif [[ "$HAS_CODE" == "true" ]]; then
          DEPLOY_TYPE="code-only"
          echo "üìù Deploy apenas de c√≥digo"
        elif [[ "$HAS_CONFIG" == "true" ]]; then
          DEPLOY_TYPE="config-only"
          echo "‚öôÔ∏è Deploy apenas de configura√ß√£o"
        else
          DEPLOY_TYPE="minimal"
          echo "üìã Deploy m√≠nimo (docs/workflows)"
        fi
        
        # Definir outputs
        echo "has_code_changes=$HAS_CODE" >> $GITHUB_OUTPUT
        echo "has_package_changes=$HAS_PACKAGE" >> $GITHUB_OUTPUT
        echo "has_config_changes=$HAS_CONFIG" >> $GITHUB_OUTPUT
        echo "needs_restart=$NEEDS_RESTART" >> $GITHUB_OUTPUT
        echo "deploy_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT

  deploy:
    name: üöÄ Deploy Docker
    runs-on: ubuntu-latest
    needs: analyze-changes
    timeout-minutes: 45
    
    steps:
    - name: üìã Info do Deploy Docker
      run: |
        echo "üöÄ Deploy UrbanMail Server com Docker"
        echo "=============================================="
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "Tipo de Deploy: ${{ needs.analyze-changes.outputs.deploy_type }}"
        echo "Mudan√ßas de C√≥digo: ${{ needs.analyze-changes.outputs.has_code_changes }}"
        echo "Mudan√ßas de Depend√™ncias: ${{ needs.analyze-changes.outputs.has_package_changes }}"
        echo "Precisa Restart: ${{ needs.analyze-changes.outputs.needs_restart }}"
        echo "=============================================="

    - name: üîë Configurar SSH
      run: |
        echo "üîë Configurando SSH para deploy..."
        
        # Instalar sshpass para autentica√ß√£o por senha
        sudo apt-get update -qq
        sudo apt-get install -y sshpass
        
        # Configurar SSH com otimiza√ß√µes para conex√µes longas
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Configurar SSH client com keepalive
        cat > ~/.ssh/config << 'EOL'
        Host *
          ServerAliveInterval 60
          ServerAliveCountMax 120
          TCPKeepAlive yes
          ControlMaster auto
          ControlPath ~/.ssh/control-%h-%p-%r
          ControlPersist 600
          ConnectTimeout 30
        EOL
        chmod 600 ~/.ssh/config
        
        # Adicionar host conhecido para evitar prompt de verifica√ß√£o
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
        
        # Testar conex√£o SSH com senha e keepalive
        echo "üîç Testando conex√£o SSH com configura√ß√µes otimizadas..."
        if sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'Conex√£o SSH bem-sucedida'"; then
          echo "‚úÖ SSH configurado e testado com sucesso"
        else
          echo "‚ùå Falha na conex√£o SSH. Verifique se:"
          echo "  1. A secret VPS_PASSWORD cont√©m a senha correta"
          echo "  2. O servidor ${{ env.VPS_HOST }} est√° acess√≠vel"
          echo "  3. O usu√°rio ${{ env.VPS_USER }} existe e aceita autentica√ß√£o por senha"
          exit 1
        fi

    - name: üîç Verificar e instalar Docker na VPS
      run: |
        echo "üîç Verificando e instalando Docker se necess√°rio..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo '=== Verificando Docker na VPS ==='
          
          # Verificar se Docker est√° instalado
          if ! command -v docker &> /dev/null; then
            echo 'üì¶ Docker n√£o encontrado, instalando...'
            
            # Atualizar sistema
            apt-get update -y
            
            # Instalar depend√™ncias
            apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
            
            # Adicionar chave GPG do Docker
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            
            # Adicionar reposit√≥rio Docker
            echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Instalar Docker
            apt-get update -y
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            
            # Iniciar Docker
            systemctl start docker
            systemctl enable docker
            
            echo '‚úÖ Docker instalado com sucesso'
          else
            echo '‚úÖ Docker j√° est√° instalado'
          fi
          
          # Verificar vers√£o do Docker
          echo 'Docker version:'
          docker --version
          
          echo ''
          echo 'Docker service status:'
          systemctl is-active docker || systemctl start docker
          
          echo ''
          echo 'Docker Containers atuais:'
          docker ps --format 'table {{.Names}}\t{{.Status}}' | grep ${{ env.CONTAINER_NAME }} || echo 'Container n√£o rodando'
          
          echo ''
          echo 'Configura√ß√£o de Firewall/Porta ${{ env.APP_PORT }}:'
          # Verificar se a porta est√° sendo usada
          netstat -tulpn | grep :${{ env.APP_PORT }} || echo 'Porta ${{ env.APP_PORT }} livre'
          
          # Verificar se iptables est√° bloqueando a porta
          iptables -L INPUT -n | grep ${{ env.APP_PORT }} || echo 'Nenhuma regra espec√≠fica para porta ${{ env.APP_PORT }}'
          
          echo ''
          echo 'Ruby version:'
          ruby --version || echo 'Ruby n√£o instalado'
          
          echo ''
          echo '√öltima atualiza√ß√£o:'
          cd ${{ env.APP_DIR }} && git log --oneline -1 2>/dev/null || echo 'Reposit√≥rio n√£o inicializado'
        "

    - name: üì• Checkout do c√≥digo
      uses: actions/checkout@v4
    
    # Assets ser√£o compilados dentro do Docker build

    - name: üì¶ Transferir c√≥digo para VPS
      run: |
        echo "üì¶ Transferindo c√≥digo para VPS via rsync..."
        
        # Instalar rsync
        sudo apt-get update -qq
        sudo apt-get install -y rsync
        
        # Log detalhado da conectividade
        echo "üîç Verificando conectividade SSH antes da transfer√™ncia..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no -v ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Conectividade SSH confirmada'
          free -h
          df -h /
          docker --version
        " 2>&1 | head -20
        
        # Limpar diret√≥rio remoto
        echo "üßπ Limpando diret√≥rio remoto..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          rm -rf ${{ env.APP_DIR }}
          mkdir -p ${{ env.APP_DIR }}
          echo 'Diret√≥rio limpo e recriado'
        "
        
        # Transferir c√≥digo usando rsync com logs detalhados
        echo "üöÄ Iniciando transfer√™ncia rsync..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" rsync -avz --delete --progress \
          --exclude='.git/' \
          --exclude='vendor/bundle/' \
          --exclude='.claude/' \
          --exclude='*.log' \
          --exclude='*.tmp' \
          --exclude='.DS_Store' \
          --exclude='log/' \
          --exclude='tmp/' \
          --exclude='spec/' \
          --exclude='public/assets/' \
          -e "ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60" \
          ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.APP_DIR }}/
        
        # Verificar transfer√™ncia com logs detalhados
        echo "‚úÖ Verificando transfer√™ncia..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          echo 'üìä Status da transfer√™ncia:'
          echo '  - Diret√≥rio atual:' \$(pwd)
          echo '  - Espa√ßo em disco:' \$(df -h . | tail -1)
          echo '  - Total de arquivos:' \$(find . -type f | wc -l)
          
          if [ -d app ] && [ -f Gemfile ] && [ -f config.ru ]; then
            echo '‚úÖ C√≥digo Rails transferido com sucesso'
            echo 'üìÇ Estrutura transferida:'
            ls -la | grep -E '(app|config|lib|Gemfile)' || echo 'Verificando estrutura...'
            echo 'üìÇ Gemfile:' \$(wc -l Gemfile 2>/dev/null || echo 'N/A')
            echo 'üìÇ Config.ru:' \$(wc -l config.ru 2>/dev/null || echo 'N/A')
          else
            echo '‚ùå ERRO: Estrutura Rails n√£o encontrada!'
            echo 'üìÇ Conte√∫do atual do diret√≥rio:'
            ls -la
            echo 'üìÇ Estrutura de diret√≥rios:'
            find . -maxdepth 2 -type d
            exit 1
          fi
        "

    - name: üöÄ Deploy usando Docker
      run: |
        echo "üöÄ Executando deploy com Docker..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Deploy UrbanMail Server usando Docker com isolamento completo
          echo 'üöÄ Executando deploy UrbanMail Server com Docker (isolado)...'
          
          # Parar e remover container anterior se existir
          echo 'üîÑ Parando container anterior...'
          docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          
          # Criar rede Docker isolada para UrbanMail
          echo 'üåê Criando rede Docker isolada...'
          if ! docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
            docker network create ${{ env.DOCKER_NETWORK }}
            echo '  ‚úÖ Rede ${{ env.DOCKER_NETWORK }} criada com sucesso'
          else
            echo '  ‚úÖ Rede ${{ env.DOCKER_NETWORK }} j√° existe'
          fi
          
          # Verificar se a rede foi criada corretamente
          if docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
            echo '  ‚úÖ Rede ${{ env.DOCKER_NETWORK }} confirmada'
            docker network inspect ${{ env.DOCKER_NETWORK }} --format '{{.Name}}: {{.Driver}}'
          else
            echo '  ‚ùå Falha ao criar/verificar rede ${{ env.DOCKER_NETWORK }}'
            echo '  üìã Redes Docker dispon√≠veis:'
            docker network ls
            exit 1
          fi
          
          # Criar volumes Docker nomeados para persist√™ncia de dados
          echo 'üíæ Criando volumes Docker nomeados...'
          docker volume create ${{ env.DATA_VOLUME }} 2>/dev/null || echo '  (volume data j√° existe)'
          docker volume create ${{ env.CONFIG_VOLUME }} 2>/dev/null || echo '  (volume config j√° existe)'
          docker volume create ${{ env.DB_VOLUME }} 2>/dev/null || echo '  (volume db j√° existe)'
          
          # Verificar processos Docker ativos (sem matar)
          echo 'üíÄ Verificando processos Docker...'
          if pgrep -f 'docker build' >/dev/null 2>&1; then
            echo '  ‚ö†Ô∏è Processos docker build encontrados (continuando)'
          fi
          if pgrep -f 'npm ci' >/dev/null 2>&1; then
            echo '  ‚ö†Ô∏è Processos npm ci encontrados (continuando)'
          fi
          echo '  ‚úÖ Verifica√ß√£o conclu√≠da'
          
          # Limpeza Docker simplificada
          echo 'üßπ Limpando recursos Docker...'
          
          # Verificar se Docker est√° funcionando
          if ! docker --version >/dev/null 2>&1; then
            echo '‚ùå Docker n√£o encontrado!'
            exit 1
          fi
          
          # Verificar se o servi√ßo Docker est√° rodando
          if ! systemctl is-active --quiet docker; then
            echo 'üîÑ Iniciando servi√ßo Docker...'
            systemctl start docker
            sleep 5
          fi
          
          # Teste b√°sico do Docker
          if ! docker info >/dev/null 2>&1; then
            echo '‚ùå Docker n√£o est√° funcionando corretamente!'
            systemctl status docker
            exit 1
          fi
          
          echo '‚úÖ Docker est√° funcionando corretamente'
          
          # Limpeza b√°sica e segura
          echo '  - Removendo imagem anterior se existir...'
          docker rmi ${{ env.IMAGE_NAME }}:latest 2>/dev/null || echo '    (nenhuma imagem para remover)'
          
          echo '  - Limpeza r√°pida de recursos n√£o utilizados...'
          docker system prune -f 2>/dev/null || echo '    (falha na limpeza, continuando)'
          
          echo '  ‚úÖ Limpeza conclu√≠da'
          
          # Build da imagem Docker com retry autom√°tico
          echo 'üèóÔ∏è Building Docker image com retry autom√°tico...'
          
          # Fun√ß√£o de retry para docker build
          build_with_retry() {
            local max_attempts=3
            local attempt=1
            local timeout_duration=1800  # 30 minutos
            
            while [ \$attempt -le \$max_attempts ]; do
              echo \"üîÑ Tentativa \$attempt/\$max_attempts do Docker build...\"
              
              # Usar timeout e Dockerfile padr√£o da aplica√ß√£o Rails
              if timeout \$timeout_duration docker build --network=host --no-cache --pull -t ${{ env.IMAGE_NAME }}:latest .; then
                echo \"‚úÖ Docker build bem-sucedido na tentativa \$attempt\"
                return 0
              else
                local exit_code=\$?
                echo \"‚ùå Docker build falhou na tentativa \$attempt (exit code: \$exit_code)\"
                
                if [ \$attempt -eq \$max_attempts ]; then
                  echo \"üí• Todas as tentativas de build falharam\"
                  return \$exit_code
                fi
                
                # Limpar containers e imagens √≥rf√£s antes de retry
                echo \"üßπ Limpando recursos Docker antes do retry...\"
                docker system prune -f --volumes 2>/dev/null || true
                docker builder prune -f 2>/dev/null || true
                
                # Aguardar antes do pr√≥ximo retry
                local wait_time=\$((attempt * 30))
                echo \"‚è≥ Aguardando \$wait_time segundos antes do pr√≥ximo retry...\"
                sleep \$wait_time
              fi
              
              attempt=\$((attempt + 1))
            done
          }
          
          # Executar build com retry
          build_with_retry
          
          # Verificar se a imagem foi criada
          if ! docker images | grep -q ${{ env.IMAGE_NAME }}; then
            echo '‚ùå Falha ao criar imagem Docker!'
            exit 1
          fi
          
          echo '‚úÖ Imagem Docker criada com sucesso'
          
          # Iniciar container isolado na porta ${{ env.APP_PORT }}
          echo 'üöÄ Iniciando container UrbanMail isolado na porta ${{ env.APP_PORT }}...'
          
          # Verificar novamente se a rede existe antes de iniciar o container
          if ! docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
            echo '‚ùå Rede ${{ env.DOCKER_NETWORK }} n√£o encontrada antes de iniciar container!'
            echo 'üìã Redes Docker dispon√≠veis:'
            docker network ls
            echo 'üîß Tentando recriar a rede...'
            docker network create ${{ env.DOCKER_NETWORK }}
            
            if ! docker network ls | grep -q ${{ env.DOCKER_NETWORK }}; then
              echo '‚ùå Falha ao criar rede ${{ env.DOCKER_NETWORK }}'
              exit 1
            else
              echo '‚úÖ Rede ${{ env.DOCKER_NETWORK }} criada com sucesso'
            fi
          fi
          
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            --network ${{ env.DOCKER_NETWORK }} \
            -p ${{ env.APP_PORT }}:5000 \
            --restart unless-stopped \
            --memory=2g \
            --cpus=2 \
            --tmpfs /tmp:noexec,nosuid,size=100m \
            --volume ${{ env.DATA_VOLUME }}:/opt/postal/data \
            --volume ${{ env.CONFIG_VOLUME }}:/config \
            --volume ${{ env.DB_VOLUME }}:/var/lib/mysql \
            --health-cmd=\"curl -f http://localhost:5000/ || exit 1\" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            -e RAILS_ENV=production \
            -e POSTAL_CONFIG_FILE_PATH=/config/postal.yml \
            -e DATABASE_URL=mysql2://postal:password@localhost/postal \
            -e SECRET_KEY_BASE=\$(openssl rand -hex 64) \
            --label app=urbanmail-postal \
            --label version=v1 \
            --label environment=production \
            ${{ env.IMAGE_NAME }}:latest
          
          # Aguardar container inicializar e verificar logs imediatamente
          echo '‚è≥ Aguardando container inicializar...'
          sleep 5
          
          # Mostrar status inicial do container
          echo 'üìã Status inicial do container:'
          docker ps -a | grep ${{ env.CONTAINER_NAME }} || echo 'Container n√£o encontrado'
          
          # Mostrar logs iniciais para debug
          echo 'üìã Logs iniciais do container:'
          docker logs ${{ env.CONTAINER_NAME }} 2>&1 || echo 'Sem logs dispon√≠veis'
          
          # Aguardar mais um pouco
          echo '‚è≥ Aguardando mais 10 segundos...'
          sleep 10
          
          # Verificar se container ainda est√° rodando
          if ! docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '‚ùå Container n√£o est√° rodando!'
            echo 'üìã Status final do container:'
            docker ps -a | grep ${{ env.CONTAINER_NAME }} || echo 'Container n√£o encontrado'
            echo 'üìã Logs completos do container:'
            docker logs ${{ env.CONTAINER_NAME }} 2>&1 || echo 'Sem logs dispon√≠veis'
            echo 'üìã Inspecionar container:'
            docker inspect ${{ env.CONTAINER_NAME }} --format='{{.State.Status}}: {{.State.Error}}' || echo 'Erro ao inspecionar'
            exit 1
          else
            echo '‚úÖ Container est√° rodando!'
          fi
          
          # Verificar se est√° funcionando
          echo 'üîç Testando UrbanMail Server...'
          for i in {1..10}; do
            # Testar conectividade com logs detalhados
            echo \"‚è≥ Tentativa \$i/10 - Testando http://localhost:${{ env.APP_PORT }}/\"
            
            # Primeiro teste com curl verbose para debug
            if [ \$i -eq 1 ] || [ \$i -eq 5 ]; then
              echo 'üîç Teste detalhado de conectividade:'
              curl -v --connect-timeout 5 --max-time 10 http://localhost:${{ env.APP_PORT }}/ 2>&1 || echo 'Curl falhou'
            fi
            
            if curl -f -s --connect-timeout 5 --max-time 10 http://localhost:${{ env.APP_PORT }}/ >/dev/null 2>&1; then
              echo '‚úÖ UrbanMail Server funcionando!'
              break
            else
              echo \"‚ùå Tentativa \$i/10 falhou\"
              if [ \$i -eq 2 ] || [ \$i -eq 5 ] || [ \$i -eq 8 ]; then
                echo 'üìã Logs do container (tentativa '\$i'):'
                docker logs ${{ env.CONTAINER_NAME }} --tail 20 2>&1
                echo 'üìã Status do container:'
                docker ps | grep ${{ env.CONTAINER_NAME }} || echo 'Container n√£o est√° mais rodando'
              fi
              sleep 10
            fi
            
            if [ \$i -eq 10 ]; then
              echo '‚ùå UrbanMail Server n√£o respondeu ap√≥s 10 tentativas'
              echo 'üìã Logs completos do container:'
              docker logs ${{ env.CONTAINER_NAME }}
              echo 'üìã Status dos processos no container:'
              docker exec ${{ env.CONTAINER_NAME }} ps aux || echo 'Container n√£o est√° acess√≠vel'
              exit 1
            fi
          done
          
          echo '‚úÖ UrbanMail Server deployed successfully on port ${{ env.APP_PORT }}'
          echo 'üìä Status do container:'
          docker ps | grep ${{ env.CONTAINER_NAME }}
          echo '‚úÖ Deploy containerizado conclu√≠do'
        "

    - name: üåê Configurar Nginx para UrbanMail
      run: |
        echo "üåê Configurando Nginx para UrbanMail Server..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          echo 'üîß Configurando proxy reverso isolado para UrbanMail...'
          
          # Verificar se Nginx est√° instalado e rodando
          if ! systemctl is-active --quiet nginx; then
            echo 'üì¶ Nginx n√£o est√° rodando, iniciando...'
            systemctl start nginx || echo 'Falha ao iniciar Nginx'
          fi
          
          # Criar configura√ß√£o Nginx isolada para UrbanMail
          cat > /etc/nginx/sites-available/urbanmail-v2.conf << 'EOF'
        # UrbanMail Postal - Configura√ß√£o isolada
        upstream urbanmail_backend {
            server 127.0.0.1:3030 max_fails=3 fail_timeout=30s;
            keepalive 32;
        }

        server {
            listen 80;
            server_name urbanmail.com.br www.urbanmail.com.br;

            # Rate limiting
            limit_req_zone \$binary_remote_addr zone=urbanmail:10m rate=10r/s;
            limit_req zone=urbanmail burst=20 nodelay;

            # Configura√ß√µes de seguran√ßa espec√≠ficas do UrbanMail
            add_header X-Frame-Options DENY;
            add_header X-Content-Type-Options nosniff;
            add_header X-XSS-Protection \"1; mode=block\";
            add_header Referrer-Policy \"strict-origin-when-cross-origin\";
            add_header X-App \"UrbanMail-Postal\" always;

            # Client settings
            client_max_body_size 10M;
            client_body_timeout 60s;

            # Proxy para UrbanMail Server (isolado)
            location / {
                proxy_pass http://urbanmail_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection \"upgrade\";
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_set_header X-App-Name \"UrbanMail\";
                proxy_cache_bypass \$http_upgrade;
                proxy_connect_timeout 10s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }

            # Health check endpoint
            location /health {
                proxy_pass http://urbanmail_backend/;
                access_log off;
                add_header X-Health-Check \"UrbanMail-Postal\" always;
            }

            # Logs espec√≠ficos do UrbanMail
            access_log /var/log/nginx/urbanmail_v2_access.log combined;
            error_log /var/log/nginx/urbanmail_v2_error.log warn;
        }
        EOF
          
          # Ativar site UrbanMail isolado
          echo 'üîó Ativando configura√ß√£o Nginx...'
          # Remover configura√ß√£o antiga se existir
          rm -f /etc/nginx/sites-enabled/urbanmail.conf 2>/dev/null || true
          # Ativar nova configura√ß√£o
          ln -sf /etc/nginx/sites-available/urbanmail-v2.conf /etc/nginx/sites-enabled/urbanmail-v2.conf
          
          # Testar configura√ß√£o Nginx
          if nginx -t; then
            echo '‚úÖ Configura√ß√£o Nginx v√°lida'
            systemctl reload nginx
            echo '‚úÖ Nginx recarregado'
          else
            echo '‚ùå Erro na configura√ß√£o Nginx'
            exit 1
          fi
          
          echo '‚úÖ Configura√ß√£o do Nginx conclu√≠da'
        "

    - name: üîç Verifica√ß√£o Final
      run: |
        echo "üîç Verifica√ß√£o final..."
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          
          # Verificar status do container e isolamento
          echo 'üîç Verificando isolamento do container UrbanMail:'
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo '‚úÖ Container UrbanMail rodando'
            echo 'üìä Detalhes do container:'
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Networks}}' | grep ${{ env.CONTAINER_NAME }}
            
            echo 'üåê Rede Docker:'
            docker network ls | grep ${{ env.DOCKER_NETWORK }} || echo '  (rede n√£o encontrada)'
            
            echo 'üíæ Volumes Docker:'
            docker volume ls | grep -E '(${{ env.DATA_VOLUME }}|${{ env.UPLOADS_VOLUME }})' || echo '  (volumes n√£o encontrados)'
            
            echo 'üè∑Ô∏è Labels do container:'
            docker inspect ${{ env.CONTAINER_NAME }} --format '{{range \$key, \$value := .Config.Labels}}{{printf \"%s=%s\n\" \$key \$value}}{{end}}' | grep -E '(app|version|environment)' || echo '  (sem labels relevantes)'
          else
            echo '‚ùå Container UrbanMail n√£o encontrado'
            exit 1
          fi
          
          # Verificar health check da aplica√ß√£o (localhost)
          echo 'üîç Testando UrbanMail Server (localhost)...'
          if curl -f -s http://localhost:${{ env.APP_PORT }}/ >/dev/null 2>&1; then
            echo '‚úÖ UrbanMail Server respondendo no localhost:${{ env.APP_PORT }}'
            echo 'üìã Resposta da aplica√ß√£o:'
            curl -s http://localhost:${{ env.APP_PORT }}/ | head -10 || echo 'Falha ao obter resposta'
          else
            echo '‚ùå UrbanMail Server n√£o est√° respondendo no localhost'
            docker logs ${{ env.CONTAINER_NAME }} --tail 10
            exit 1
          fi
          
          # Verificar health check via Nginx (dom√≠nio) - se configurado
          echo 'üîç Testando conectividade do dom√≠nio ${{ env.DOMAIN }}...'
          
          # Testar se o dom√≠nio responde (HTTP ou HTTPS)
          if curl -f -s -I http://${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '‚úÖ Dom√≠nio ${{ env.DOMAIN }} respondendo via HTTP'
            
            # Verificar se h√° redirecionamento para HTTPS
            if curl -f -s -I http://${{ env.DOMAIN }}/ | grep -q '301\\|302'; then
              echo '‚úÖ Redirecionamento HTTP ‚Üí HTTPS configurado'
            else
              echo 'üìù Site respondendo em HTTP (SSL pode n√£o estar configurado ainda)'
            fi
          else
            echo '‚ö†Ô∏è Dom√≠nio ${{ env.DOMAIN }} n√£o est√° respondendo via HTTP'
          fi
          
          # Testar HTTPS se dispon√≠vel
          if curl -f -s -k https://${{ env.DOMAIN }}/ >/dev/null 2>&1; then
            echo '‚úÖ Site HTTPS respondendo em https://${{ env.DOMAIN }}'
          else
            echo 'üìù HTTPS n√£o dispon√≠vel (SSL pode n√£o estar configurado)'
          fi
          
          # Testar dom√≠nio sem www (urbanmail.com.br)
          if curl -f -s -k https://urbanmail.com.br/ >/dev/null 2>&1; then
            echo '‚úÖ Site HTTPS respondendo em https://urbanmail.com.br'
          elif curl -f -s http://urbanmail.com.br/ >/dev/null 2>&1; then
            echo '‚úÖ Site HTTP respondendo em http://urbanmail.com.br'
          else
            echo 'üìù Dom√≠nio urbanmail.com.br pode n√£o estar configurado'
          fi
          
        "

    - name: üìä Relat√≥rio do Deploy
      if: always()
      run: |
        echo "üìä RELAT√ìRIO DO DEPLOY DOCKER"
        echo "============================="
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          echo 'Tipo de Deploy: ${{ needs.analyze-changes.outputs.deploy_type }}'
          echo 'Restart Executado: ${{ needs.analyze-changes.outputs.needs_restart }}'
          echo 'Depend√™ncias Atualizadas: ${{ needs.analyze-changes.outputs.has_package_changes }}'
          echo ''
          
          echo '=== Status do Container Isolado ==='
          if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
            echo 'üìä Container UrbanMail:'
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}' | head -1
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}' | grep ${{ env.CONTAINER_NAME }}
            
            echo ''
            echo 'üåê Recursos Docker isolados:'
            echo '  - Rede: ${{ env.DOCKER_NETWORK }}'
            echo '  - Volume Data: ${{ env.DATA_VOLUME }}'
            echo '  - Volume Config: ${{ env.CONFIG_VOLUME }}'
            echo '  - Volume DB: ${{ env.DB_VOLUME }}'
            echo '  - Imagem: ${{ env.IMAGE_NAME }}:latest'
          else
            echo '‚ùå Container UrbanMail n√£o encontrado'
          fi
          
          echo ''
          echo '=== √öltimo Commit ==='
          cd ${{ env.APP_DIR }} && git log --oneline -1 2>/dev/null || echo 'Reposit√≥rio git n√£o inicializado (deploy via rsync)'
          
          echo ''
          echo 'üåê URLs de Acesso:'
          echo '  - Site Principal: https://${{ env.DOMAIN }}'
          echo '  - Site Alternativo: https://urbanmail.com.br'
          echo '  - Acesso Direto: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}'
          echo '  - API Health: https://${{ env.DOMAIN }}/health'
          echo '‚ö° Deploy Docker UrbanMail conclu√≠do!'
        "

    - name: üéâ Deploy Conclu√≠do
      run: |
        echo "üéâ DEPLOY URBANMAIL POSTAL ISOLADO REALIZADO COM SUCESSO!"
        echo "‚ö° Tipo: ${{ needs.analyze-changes.outputs.deploy_type }}"
        echo "üê≥ Deploy completamente isolado em VPS compartilhada:"
        echo "   - Container: ${{ env.CONTAINER_NAME }}"
        echo "   - Rede isolada: ${{ env.DOCKER_NETWORK }}"
        echo "   - Volumes nomeados: ${{ env.DATA_VOLUME }}, ${{ env.CONFIG_VOLUME }}, ${{ env.DB_VOLUME }}"
        echo "   - Imagem √∫nica: ${{ env.IMAGE_NAME }}:latest"
        echo "üîí SSL/HTTPS configurado com Let's Encrypt"
        echo ""
        echo "üåê URLs de Acesso:"
        echo "  - Site Principal: https://${{ env.DOMAIN }}"
        echo "  - Site Alternativo: https://urbanmail.com.br"
        echo "  - Acesso Direto VPS: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo "  - API Health: https://${{ env.DOMAIN }}/health"
        echo ""
        echo "‚úÖ UrbanMail est√° online e funcionando!"